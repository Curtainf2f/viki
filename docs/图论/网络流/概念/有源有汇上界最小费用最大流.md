# Spfa
复杂度$O(k*V*E)$

## 代码

```cpp
const int N = 505;
const int M = N * N;
const int INF = 0x7f7f7f7f;

class Graphics
{
private:
	struct Edge
	{
		int to, cost, vol, next;
	} edge[M << 1];
	int first[N], sign, prePoint[N], preEdge[N], dist[N];
	int sumOfPoint, start, end;
	bool spfa() {
	    vector<bool> visit(sumOfPoint+1, false);
		for (int i = 0; i <= sumOfPoint; ++i) {
			prePoint[i] = -1;
			dist[i] = INF;
		}
		dist[start] = 0;
		queue<int> bfs;
		bfs.push(start);
		visit[start] = true;
		while(!bfs.empty()) {
			int now = bfs.front();
			bfs.pop();
			visit[now] = 0;
			for(int i = first[now]; i != -1; i = edge[i].next) {
				int to = edge[i].to, cost = edge[i].cost, vol = edge[i].vol;
				if(vol > 0 && dist[now] + cost < dist[to]) {
					dist[to] = dist[now] + cost;
					prePoint[to] = now;
					preEdge[to] = i;
					if(!visit[to]){
                        bfs.push(to);
                        visit[to] = true;
					}
				}
			}
		}
		return prePoint[end] != -1;
	}
public:
	void clear(int n) {
		sumOfPoint = n;
		for (int i = 0; i <= n; ++i) {
			first[i] = -1;
		}
		sign = 0;
	}
	inline void addEdgeOneWay(int u, int v, int vol, int cost) {
		edge[sign].to= v;
		edge[sign].vol = vol;
		edge[sign].cost = cost;
		edge[sign].next = first[u];
        first[u] = sign ++;
	}
	inline void addNetWorkEdge(int u, int v, int vol, int cost) {
		addEdgeOneWay(u, v, vol, cost);
		addEdgeOneWay(v, u, 0, -cost);
	}
	int minCostFlow(int u, int v) {
		start = u;
		end = v;
		int cost = 0;
		int flow = 0;
		while(spfa()) {
			int augmentMaxFlow = INF;
			for(int now = end; now != start; now = prePoint[now]) {
				if(edge[preEdge[now]].vol < augmentMaxFlow) {
					augmentMaxFlow = edge[preEdge[now]].vol;
				}
			}
			flow += augmentMaxFlow;
			cost += augmentMaxFlow * dist[end];
			for(int now = end; now != start; now = prePoint[now]) {
				edge[preEdge[now]].vol -= augmentMaxFlow;
				edge[preEdge[now] ^ 1].vol += augmentMaxFlow;
			}
		}
		return cost;
	}
}graph;
```

# Dijkstra(堆优化)

最短路性质知$dist(v) >= w(u,v) + dist(u)$

得$dist(v) - w(u,v) - dist(u) >= 0$

令$dist(v)'= dist(v) - w(u,v) - dist(u)$

有$dist(v)'= dist(v) + w(v,u) - dist(u)$

令$h(u) = dist(u)$

得$dist(v)' = h(v) - h(u) +w(v,u)$

有$dist(t)' = w(s,2) + h(s) - h(2) + w(2,1) + h(2) - h(1) + w(1,t) + h(1) - h(t)$

$dist(t)'  = w(s,2)+h(s) + w(2,1) + w(1,t) - h(t)$

$dist(t)' = dist(t) + h(s) - h(t)$

起点必定有$dist(s) = 0$所以$h(s) = 0$

得$dist(t)' = dist(t) - h(t)$

```cpp  
h[i] += (dist[i] != INF) ? dist[i] : 0;
```

设任意点$u$

$dist(u)' = \Sigma(w(u,v) + h(u) - h(v))$
$dist(u)' = dist(u) - h(u)$
$h(u) = dist(u) = dist(u)' + h(u)$

所以本次增广结果从源点到汇点的花费为$h(t) = dist(t)'+h(t)$

复杂度$O(E*log(V)*E)$

## 代码

```cpp
const int N = 505;
const int M = N * N;
const int INF = 0x7f7f7f7f;

class Graphics
{
private:
	struct Edge
	{
		int to, cost, vol, next;
	} edge[M << 1];
	int first[N], sign, prePoint[N], preEdge[N], dist[N];
    int h[N];
	int sumOfPoint, start, end;
    void dijkstra() {
        fill(dist, dist + 1 + sumOfPoint, INF);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int> > > q;
        dist[start] = 0;
        q.push(make_pair(0, start));
        while(!q.empty()) {
            pair<int, int> now = q.top();
            q.pop();
            if(dist[now.second] < now.first) continue;
            for(int i = first[now.second]; i != -1; i = edge[i].next) {
                int to = edge[i].to, w = edge[i].cost, vol = edge[i].vol;
                if(!vol) continue;
                if(dist[to] == INF || dist[to] > now.first + w + h[now.second] - h[to]) { // dist[u] + w(u,v) + h(u) - h(v)
                    dist[to] = now.first + w + h[now.second] - h[to];
                    prePoint[to] = now.second;
                    preEdge[to] = i;
                    q.push(make_pair(dist[to], to));
                }
            }
        }
    }
public:
	void clear(int n) {
		sumOfPoint = n;
        fill(h, h + n + 1, 0);
        fill(first, first + n + 1, -1);
		sign = 0;
	}
	inline void addEdgeOneWay(int u, int v, int vol, int cost) {
		edge[sign].to= v;
		edge[sign].vol = vol;
		edge[sign].cost = cost;
		edge[sign].next = first[u];
        first[u] = sign ++;
	}
	inline void addNetWorkEdge(int u, int v, int vol, int cost) {
		addEdgeOneWay(u, v, vol, cost);
		addEdgeOneWay(v, u, 0, -cost);
	}
	int minCostFlow(int u, int v) {
		start = u;
		end = v;
		int cost = 0;
		int flow = 0;
		while(1) {
            dijkstra();
            if(dist[end] == INF) break;
            for(register int i = 1; i <= sumOfPoint; i ++)
                h[i] += (dist[i] != INF) ? dist[i] : 0;
			int augmentMaxFlow = INF;
			for(int now = end; now != start; now = prePoint[now]) {
				if(edge[preEdge[now]].vol < augmentMaxFlow) {
					augmentMaxFlow = edge[preEdge[now]].vol;
				}
			}
			flow += augmentMaxFlow;
			cost += augmentMaxFlow * h[end];
			for(int now = end; now != start; now = prePoint[now]) {
				edge[preEdge[now]].vol -= augmentMaxFlow;
				edge[preEdge[now] ^ 1].vol += augmentMaxFlow;
			}
		}
		return cost;
	}
}graph;
```