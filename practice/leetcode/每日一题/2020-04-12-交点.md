# 2020-4-12-交点

给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。

要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。


示例 1：
```
输入：
line1 = {0, 0}, {1, 0}
line2 = {1, 1}, {0, -1}
输出： {0.5, 0}
```
示例 2：
```
输入：
line1 = {0, 0}, {3, 3}
line2 = {1, 1}, {2, 2}
输出： {1, 1}
```
示例 3：
```
输入：
line1 = {0, 0}, {1, 1}
line2 = {1, 0}, {2, 1}
输出： {}，两条线段没有交点
```

提示：

坐标绝对值不会超过 2^7
输入的坐标均是有效的二维坐标
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-lcci
```

# 代码

```cpp
class Solution {
public:
    vector<double> intersection(vector<int>& start1, vector<int>& end1, vector<int>& start2, vector<int>& end2) {
        vector<double> ans;
        // 两条线重合使用
        vector<pair<int, int> > p;
        p.push_back({start1[0], start1[1]});
        p.push_back({end1[0], end1[1]});
        p.push_back({start2[0], start2[1]});
        p.push_back({end2[0], end2[1]});
        bool ok = true;
        if(p[0] > p[1]) swap(p[0], p[1]);
        if(p[2] > p[3]) swap(p[2], p[3]);
        if(p[0] > p[2]){
            swap(p[0], p[2]);
            swap(p[1], p[3]);
        }
        if(p[0] < p[1] && p[1] < p[2] && p[2] < p[3]) ok = false;
        // 斜率不存在
        if(end1[0] - start1[0] == 0 && end2[0] - start2[0] == 0){
            if(ok && end1[0] == end2[0]){
                sort(p.begin(), p.end());
                ans.push_back(p[1].first);
                ans.push_back(p[1].second);
            }
            return ans;
        }else if(end1[0] - start1[0] == 0){
            // y = (x - x2)*(y1 - y2)/(x1 - x2) + y2
            double x = end1[0];
            double y = 1LL*(end1[0] - end2[0])*(start2[1] - end2[1])*1.0/(start2[0] - end2[0]) + end2[1];
            if(x + 0.000001 > p[0].first && x + 0.000001 > p[2].first && x - 0.000001 < p[1].first && x - 0.000001 < p[3].first){
                ans.push_back(x);
                ans.push_back(y);
            }
            return ans;
        }else if(end2[0] - start2[0] == 0){
            double x = end2[0];
            double y = 1LL*(end2[0] - end1[0])*(start1[1] - end1[1])*1.0/(start1[0] - end1[0]) + end1[1];
            if(x + 0.000001 > p[0].first && x + 0.000001 > p[2].first && x - 0.000001 < p[1].first && x - 0.000001 < p[3].first){
                ans.push_back(x);
                ans.push_back(y);
            }
            return ans;
        }
        // 斜率存在
        else{
            // 平行
            if(1LL*(end1[1] - start1[1]) * (end2[0] - start2[0]) == 1LL*(end1[0] - start1[0])*(end2[1] - start2[1])){
                // (y - y2)/(y1 - y2) = (x - x2)/(x1 - x2)
                if(ok && 1LL*(end2[1]-end1[1])*(start1[0]-end1[0]) == 1LL*(end2[0]-end1[0])*(start1[1]-end1[1])){
                    sort(p.begin(), p.end());
                    ans.push_back(p[1].first);
                    ans.push_back(p[1].second);
                }
                return ans;
            }
            // (x-x12)*(y11-y12)/(x11-x12) = (x-x22)*(y21-y22)/(x21-x22) + y22 - y12 
            // x(y11-y12) + x12(y12-y11)
            // x(y21-y22)*(x11-x12)/(x21-x22) + (x22(y22-y21)/(x21-x22)+y22-y12)*(x11-x12)
            // x(y11-y12-((y21-y22)*(x11-x12)/(x21-x22)))
            // (x22(y22-y21)/(x21-x22)+y22-y12)*(x11-x12) - x12(y12-y11)
            double x11 = start1[0], x12 = end1[0], x21 = start2[0], x22 = end2[0];
            double y11 = start1[1], y12 = end1[1], y21 = start2[1], y22 = end2[1];
            double x = ((x22*(y22-y21)/(x21-x22)+y22-y12)*(x11-x12)-x12*(y12-y11))/(y11-y12-((y21-y22)*(x11-x12)/(x21-x22)));
            double y = (x - x12)*(y11 - y12)/(x11 - x12) + y12;
            if(x + 0.000001 > p[0].first && x + 0.000001 > p[2].first && x - 0.000001 < p[1].first && x - 0.000001 < p[3].first){
                ans.push_back(x);
                ans.push_back(y);
            }
            return ans;
        }
    }
};
```

# 思路

+ 两直线重合解
> 无论是重合部分全覆盖或者半覆盖，都为下面那种情况
> `--==--` 解为从小到大第二个点

+ Line1斜率不存在 且 Line2斜率不存在
> 平行，如果无解则四个点的坐标是有序的
> 否则有解输出从小到大第二个点

+ 其中一条直线斜率存在，另一条不存在
> 以直线来说必有交点

+ 斜率都存在
> 判断平行： 两直线斜率相等
> (y11 - y12)/(x11 - x12) = (y21 - y22)/(x21 - x22)
> 中间数字代表第几条直线，最后一个数字1为起始点，2为中止点
> 由于除法会掉精，所以判断斜率相等，由于斜率存在，分母不可能为0，可移项成乘法形式
> (y11 - y12)*(x21 - x22)=(y21 - y22)*(x11 - x12)
> 平行解判断与斜率都不存在相同
>  
> 直线有交点：
> 联立 两点式
> 1. (y - y12)/(y11 - y12) = (x - x12)/(x11 - x12)
> 2. (y - y22)/(y21 - y22) = (x - x22)/(x21 - x22)
> 解得 x = ((x22*(y22-y21)/(x21-x22)+y22-y12)*(x11-x12)-x12*(y12-y11))/(y11-y12-((y21-y22)*(x11-x12)/(x21-x22)))
> 算得x，代入1或2，算得y

+ 上述算得交点都为直线的交点，需判断交点在不在两线段内
> 将x较小，或x相等y较小的点做为线段起始点
> 交点x坐标 >= 线段起始点x坐标 且 交点x坐标<=线段终点x坐标 即为交点在线段内