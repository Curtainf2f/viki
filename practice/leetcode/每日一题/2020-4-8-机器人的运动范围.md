# 2020-4-8-机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

示例 1：
```
输入：m = 2, n = 3, k = 1
输出：3
```

示例 2：
```
输入：m = 3, n = 1, k = 0
输出：1
```

提示：
```
1 <= n,m <= 100
0 <= k <= 20
```

# 代码:

```cpp
class Solution {
public:
    int check(int x, int y){
        int ret = 0;
        while(x){
            ret += x%10;
            x /= 10;
        }
        while(y){
            ret += y%10;
            y /= 10;
        }
        return ret;
    }
    bool f[105][105], mp[105][105];
    queue<pair<int, int> > q;
    int movingCount(int m, int n, int k) {
        for(int i = 0; i < m; i ++){
            for(int j = 0; j < n; j ++){
                if(check(i, j) <= k){
                    f[i][j] = true;
                }
            }
        }
        q.push({0, 0});
        while(q.size()){
            pair<int, int> now = q.front();
            q.pop();
            if(now.first < 0 || now.second < 0 || now.first >= m || now.second >= n) continue;
            if(mp[now.first][now.second]) continue;
            if(!f[now.first][now.second]) continue;
            mp[now.first][now.second] = true;
            q.push({now.first+1, now.second});
            q.push({now.first-1, now.second});
            q.push({now.first, now.second+1});
            q.push({now.first, now.second-1});
        }
        int ans = 0;
        for(int i = 0; i < m; i ++){
            for(int j = 0; j < n; j ++){
                if(mp[i][j]){
                    ans ++;
                }
            }
        }
        return ans;
    }
};
```

# 思路:

1. 考虑机器人哪些格子可以走

遍历整个x，y坐标的数位和最差6次，复杂度为 $O(n*m)$
将所有能走的位置用f二维数组标记

2. 从机器人的位置出发广搜遍历所有机器人能走到的格子

复杂度为$O(n*m)$

3. 扫描一遍所有机器人可走过的格子并进行统计

复杂度为$O(n*m)$

最终复杂度为$O(n*m)$
$n,m\leq100$ 在可接受范围内