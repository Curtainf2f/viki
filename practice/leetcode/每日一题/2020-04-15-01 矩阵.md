# 2020-04-15-01 矩阵

给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

示例 1:
输入:
```
0 0 0
0 1 0
0 0 0
```
输出:
```
0 0 0
0 1 0
0 0 0
```
示例 2:
输入:
```
0 0 0
0 1 0
1 1 1
```
输出:
```
0 0 0
0 1 0
1 2 1
```
注意:

给定矩阵的元素个数不超过 10000。
给定矩阵中至少有一个元素是 0。
矩阵中的元素只在四个方向上相邻: 上、下、左、右。
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/01-matrix
```

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        vector<vector<int> > ans(matrix.size(), vector<int>(matrix[0].size()));
        vector<vector<int> > vis(matrix.size(), vector<int>(matrix[0].size(), false));
        queue<tuple<int, int, int> > q;
        for(int i = 0; i < matrix.size(); i ++){
            for(int j = 0; j < matrix[i].size(); j ++){
                if(matrix[i][j] == 0){
                    q.push({i, j, 0});
                }
            }
        }
        while(q.size()){
            tuple now = q.front();
            q.pop();
            if(get<0>(now) < 0 || get<1>(now) < 0 || get<0>(now) >= matrix.size() || get<1>(now) >= matrix[0].size()) continue;
            if(vis[get<0>(now)][get<1>(now)]) continue;
            vis[get<0>(now)][get<1>(now)] = true;
            ans[get<0>(now)][get<1>(now)] = get<2>(now);
            q.push({get<0>(now) + 1, get<1>(now), get<2>(now) + 1});
            q.push({get<0>(now) - 1, get<1>(now), get<2>(now) + 1});
            q.push({get<0>(now), get<1>(now) + 1, get<2>(now) + 1});
            q.push({get<0>(now), get<1>(now) - 1, get<2>(now) + 1});            
        }
        return ans;
    }
};
```

# 思路

将所有0点作为起始点进行广搜，复杂度$O(n)$