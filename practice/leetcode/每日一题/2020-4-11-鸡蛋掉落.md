# 2020-4-11-鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？


示例 1：
```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```
示例 2：
```
输入：K = 2, N = 6
输出：3
```
示例 3：
```
输入：K = 3, N = 14
输出：4
 ```

提示：
```
1 <= K <= 100
1 <= N <= 10000
```

```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/super-egg-drop
```

# 代码

```cpp
class Solution {
public:
    int f[111][11111];
    int dp(int K, int N){
        // dp[K][N] = 1 + min(max(dp[K-1][X-1], dp[K][N-X]))
        if(N == 0) return 0;
        if(K == 1) return N;
        if(f[K][N] != -1) return f[K][N];
        int l = 1, r = N;
        while(l + 1 < r){
            int mid = l + r >> 1;
            if(dp(K-1, mid-1) < dp(K, N-mid)){
                l = mid;
            }else{
                r = mid;
            }
        }
        f[K][N] = 1 + min(max(dp(K-1, l-1), dp(K, N-l)), max(dp(K-1, r-1), dp(K, N-r)));
        return f[K][N];
    }
    int superEggDrop(int K, int N) {
        for(int i = 0; i <= K; i ++){
            for(int j = 0; j <= N; j ++){
                f[i][j] = -1;
            }
        }
        return dp(K, N);
    }
};
```

# 思路

dp + 二分

+ 假设我们的鸡蛋扔在了X层，会发生两种情况
>1. 鸡蛋碎了，那么答案在X以下的楼层
>2. 鸡蛋没碎，那么答案在X及X以上的楼层
>我们假设第$N$层，有$K$个鸡蛋的解为$f(K, N)$
>则 $f(K, N) = 1 + min(max(f(K-1, X-1), f(K, N-X))) X \in [1,N]$
>暴力求解复杂度为$O(KN^2)$ 不符合预期

+ 当X越来越小时，$f(K,N-X)$越来越大，$f(K-1,X-1)$越来越小
> 因为对于$f(K,N-X)$需要判断的楼层越来越多了，对于$f(K-1,X-1)$需要判断的楼层越来越小了
> 由于最坏解取决于大值，所以我们要让$f(K,N-X)$和$f(K-1,X-1)$越接近越好
> 所以我们采取二分，综上所述，当X比期望值小时，$f(K-1,X-1)$ < $f(K,N-X)$，反之亦然
> 这样我们就优化掉了$X \in [1,N]$的遍历，由$O(n)优化成了O(logn)$

最终复杂度$O(KNlogN)$ 符合预期