# 社团主席选举
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```
随着又一届学生的毕业，社团主席换届选举即将进行。

一共有n个投票者和m个候选人，小易知道每一个投票者的投票对象。但是，如果小易给某个投票者一些糖果，那么这个投票者就会改变他的意向，小易让他投给谁，他就会投给谁。

由于小易特别看好这些候选人中的某一个大神，这个人的编号是1，所以小易希望能尽自己的微薄之力让他当选主席，但是小易的糖果数量有限，所以请你帮他计算，最少需要花多少糖果让1号候选人当选。某个候选人可以当选的条件是他获得的票数比其他任何候选者都多。


输入描述:
第一行两个整数n和m，表示投票者的个数和候选人的个数。
接下来n行，每一行两个整数x和y，x表示这个投票者的投票对象，y表示需要花多少个糖果让这个人改变意向。
满足1 <= n, m <= 3000，1 <= x <= m，1 <= y <= 109。

输出描述:
一个整数，糖果的最小花费。

输入例子1:
```
1 2
1 20
```

输出例子1:
```
0
```

输入例子2:
```
5 5
2 5
3 5
4 5
5 6
5 1
```

输出例子2:
```
6
```

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N = 3333;
const LL INF = 0x3f3f3f3f3f3f3f3fLL;

vector<int> p[N];

int main(){
    int n, m;
    cin >> n >> m;
    int _max = 0;
    for(int i = 1; i <= n; i ++){
        int x, y;
        cin >> x >> y;
        p[x].push_back(y);
        _max = max(_max, (int)p[x].size());
    }
    for(int i = 1; i <= m; i ++) sort(p[i].begin(), p[i].end());
    LL ans = INF;
    for(int i = _max + 1; i >= 1; i --){
        priority_queue<int, vector<int>, greater<int> > ticket;
        int now = p[1].size();
        LL cur = 0;
        for(int j = 2; j <= m; j ++){
            for(int s = 0; s < (int)p[j].size() - i + 1; s ++){
                cur += p[j][s];
                now ++;
            }
            for(int s = ((int)p[j].size() - i + 1 > 0 ? p[j].size() - i + 1 : 0); s < p[j].size(); s ++){
                ticket.push(p[j][s]);
            }
        }
        while(ticket.size() && now < i){
            cur += ticket.top();
            ticket.pop();
            now ++;
        }
        ans = min(ans, cur);
    }
    cout << ans << endl;
    return 0;
}
```

# 思路

暴力枚举1号的至少得票数


+ 凡是超过至少得票数的选员，就将他票中最便宜的票依次挖走，直到他的票少于1号的至少得票数

+ 当把超过至少得票数的选员的票都挖走后，1号的票还未达到至少得票数，则在剩下的敌对票中，依次挖走最便宜的票，直到1号票达到至少得票数

复杂度
+ 排序共n张票，复杂度$O(nlogn)$

+ 最多只有n票，所以1号的至少得票数不会超过n+1票，当然根本不会到这么多，这里给的非常宽裕，外层循环复杂度$O(n)$

+ 内层挑各选员多的票，以及剩下的票，最坏的情况是，没有任何选员的票超过1号至少得票数，所有的票都是待抢票，放入优先队列，复杂度$O(nlogn)$

最终复杂度 $O(n^2logn)$