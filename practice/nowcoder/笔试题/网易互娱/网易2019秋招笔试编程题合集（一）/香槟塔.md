# 香槟塔
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```
节日到啦，牛牛和妞妞邀请了好多客人来家里做客。
他们摆出了一座高高的香槟塔，牛牛负责听妞妞指挥，往香槟塔里倒香槟。
香槟塔有个很优雅的视觉效果就是如果这一层的香槟满了，就会从边缘处往下一层流去。
妞妞会发出两种指令，指令一是往第x层塔内倒体积为v的香槟，指令二是询问第k层塔香槟的体积为多少。
告诉你香槟塔每层香槟塔的初始容量，你能帮牛牛快速回答妞妞的询问吗？

输入描述:
第一行为两个整数n，m。表示香槟塔的总层数和指令条数。
第二行为n个整数ai，表示每层香槟塔的初始容量。
第三行到第2+m行有两种输入，一种输入是“2 x v”表示往第x层倒入体积为v的香槟；另一种输入是“1 k”表示询问第k层当前有多少香槟。
1 <= n, m <= 1000。
1 <= n ,m <= 200000，1 <= ai ,v <= 1000000000。

输出描述:
对于每个询问，输出一个整数，表示第k层香槟的容量。

输入例子1:
```
1 2
8
2 1 9
1 1
```

输出例子1:
```
8
```

输入例子2:
```
5 4
1 2 2 10 1
1 3
2 2 5
2 4 3
1 4
```
输出例子2:
```
0
4
```

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 200005;

int n, m;
int v[N], fa[N], now[N];

int find(int x){
    int f = x;
    while(f != fa[f]){
        f = fa[f];
    }
    while(x != f){
        int t = fa[x];
        fa[x] = f;
        x = t;
    }
    return f;
}

void join(int x, int y){
    int bx = find(x), by = find(y);
    fa[bx] = by;
}

void go(int x, int y){
    int bx = find(x);
    if(bx > n) return ;
    if(now[bx] + y > v[bx]){
        join(bx, bx + 1);
        go(bx + 1, y - v[bx] + now[bx]);
        now[bx] = v[bx];
    }else{
        now[bx] += y;
    }
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++) scanf("%d", &v[i]), fa[i] = i;
    fa[n+1] = n + 1;
    while(m --){
        int opt, x, y;
        scanf("%d%d", &opt, &x);
        if(opt == 1){
            printf("%d\n", now[x]);
        }else if(opt == 2){
            scanf("%d", &y);
            go(x, y);
        }
    }
    return 0;
}
```

# 思路

+ 确定哪一层的香槟会增加
> 倒在顶层的香槟满了会流向下一层，下一层也满了的话会流向再下一层，依次类推
> 使用并查集优化，可以让最坏复杂度为$O(n)$的模拟(循环向下找，直到遇到没满的香槟)，变为最坏复杂度为$O(1)$
> 如果这层的香槟满了，就将本层合并到下一层，下一次使用这层时可直接定位到满足条件的层

+ 有可能倒一次香槟会倒满多层，不仅本层装不下，下层，下下层……都装不下
> 递归调用并查集合并即可，将剩余的香槟量递归给下一层，每层分开处理
> 由于每层最多被合并一次，就算第一次倒满全部层$O(n)$，之后不论倒哪，都是$O(1)$

+ 注意最后一层溢出后，剩下的香槟直接没有了

最终复杂度$O(n)$，符合预期