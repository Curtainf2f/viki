# 买房
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```
在一条街上有n幢房子，标号从1到n，两个在标号上相差为1的房子视为相邻，这些房子中有k幢房子已有住户。
现你准备搬入这条街，你能搬入一幢房子的条件是这幢房子没有人住在里面，与此同时由于你非常热爱与邻居进行交流，故而你需要你所入住的房子两边上都有住户。
现要你求最小的可能符合要求的房子数，以及最大的可能符合要求的房子数。

Note: 就样例来说，#代表已有住户，-代表空位，这种情况（###---)，没有满足条件的房子，为最小，故输出0
最大的情况为(#-#-#-)，此种情况有二个位置满足条件，为最大，故输出2

输入描述:
输入的一行为测试用例数t(1 <= t <= 200000)，

接下来t行，每行含两个整数n和k，(1 <= n <= 1,000,000,000，0 <= k <= n)

输出描述:
对于每个用例输出最小的可能数以及最大的可能数

输入例子1:
```
6
1 0
1 1
2 0
2 1
2 2
6 4
```

输出例子1:
```
0 0
0 0
0 0
0 0
0 0
0 2
```

# 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main(){
    int t;
    cin >> t;
    while(t --){
        int n, k, ans;
        cin >> n >> k;
        if(n & 1){
            if(k > n - n / 2){
                ans = n - k;
            }else{
                ans = k - 1 > 0 ? k - 1 : 0;
            }
        }else{
            if(k > n / 2){
                ans = n - k;
            }else{
                ans = k - 1 > 0 ? k - 1 : 0;
            }
        }
        cout << 0 << " " << ans << endl;
    }
    return 0;
}
```

# 思路

最小满足，只需要将住户顺序排下去即可，`###########--`必定为0满足

先假设没有k的限制，想要达到最大满足则需要`#-#-#`这样间隔填充

分类讨论

达到最大满足，最少需填充数

+ n为奇数
> `#-#-#`，可得知最多可以有n//2个满足，最少需填充n-n//2个位置
+ n为偶数
> `#-#-#-`，可得最多可以有n//2-1个满足，最少需填充n//2个位置

最大满足数

+ k > 最少需填充数
> `#`将占用满足条件的`-`，偶数多1个未满足位置，由于k > 最少需填充数，所以偶数多出来的位置必被占
> 得剩下的空位都是满足的，所以最大满足为n-k
+ k <= 最小填充数
> 将`#`间隔放即可，全放下去最多也只能刚刚好填满整个串
> 所以最大满足为 k - 1