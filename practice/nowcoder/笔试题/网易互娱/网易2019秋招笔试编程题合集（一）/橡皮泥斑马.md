# 橡皮泥斑马
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```
小易很喜欢斑马，因为它们身上黑白相间的花纹。
一天小易得到了一串橡皮泥，这串橡皮泥只有黑色和白色，小易想把这串橡皮泥重新拼凑一下，让这个橡皮泥串中最长的连续的黑白相间的子串最长，但是小易有强迫症，所以他可以对橡皮泥串进行以下的操作0次或多次：
把橡皮泥串从某个地方切割开，将两个得到的两个串同时翻转，再拼接在一起。
这个橡皮泥串可能太长了，所以小易没有办法计算最终可以得到的最长的连续的黑白相间的子串的长度，希望你能帮他计算出这个长度。

输入描述:
一个字符串s，只包含字母'b'和字母'w'，分别表示黑色和白色的橡皮泥块。
满足1 <= |s| <= 105，|s|代表字符串的长度。

输出描述:
一个整数，表示改变之后最长的连续的黑白相间的子串的长度。

输入例子1:
```
bwbwb
```
输出例子1:
```
5
```

输入例子2:
```
wwb
```

输出例子2:
```
3
```

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
vector<int> cut;

int main(){
    cin >> s;
    char now = s[0];
    cut.push_back(0);
    for(int i = 1; i < s.size(); i ++){
        if(s[i] == now){
            cut.push_back(i);
        }else{
            now = s[i];
        }
    }
    cut.push_back(s.size());
    int _max = 0;
    for(int i = 0; i < cut.size() - 1; i ++){
        if(cut[i+1] - cut[i] > cut[_max+1] - cut[_max]){
            _max = i;
        }else if(cut[i+1] - cut[i] == cut[_max+1] - cut[_max] && (i == 1 || i == s.size() - 1)){
            _max = i;
        }
    }
    if((_max == 1 || _max == s.size() - 1)&& s[0] != s[s.size() - 1]) cout << cut[_max+1] - cut[_max] + 1 << endl;
    else cout << cut[_max+1] - cut[_max] << endl;
    return 0;
}
```

# 思路

+ 当从中间切开后，两边的字符串长度都>=2
> `......O|O.....`
> 从`|`位置切开
> 翻转后为
> `O............O`
> 之后无论怎么切，必然是`OO`情况，并不会影响黑白相间的最长串

+ 当中间切开后，其中一边的字符串长度=1
> `O|O.....X`
> 翻转后
> `OX......O`
> 使得`OX`有可能是黑白相间的情况，最长串长度+1
> 当然如果是`O|O.......O`的情况，怎么翻也不会有黑白相间的情况

找出最长串后，根据上述做出判断即可