# 翻转翻转
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```
给定一个N*M的矩阵，在矩阵中每一块有一张牌，我们假定刚开始的时候所有牌的牌面向上。
现在对于每个块进行如下操作：
> 翻转某个块中的牌，并且与之相邻的其余八张牌也会被翻转。
XXX
XXX
XXX
如上矩阵所示，翻转中间那块时，这九块中的牌都会被翻转一次。
请输出在对矩阵中每一块进行如上操作以后，牌面向下的块的个数。

输入描述:
输入的第一行为测试用例数t(1 <= t <= 100000),
接下来t行，每行包含两个整数N,M(1 <= N, M <= 1,000,000,000)

输出描述:
对于每个用例输出包含一行，输出牌面向下的块的个数

输入例子1:
```
5
1 1
1 2
3 1
4 1
2 2
```

输出例子1:
```
1
0
1
2
0
```

# 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main(){
    int t;
    cin >> t;
    while(t --){
        int n, m;
        cin >> n >> m;
        if(n == 1 && m == 1){
            cout << 1 << endl;
        }else if(n == 1){
            cout << m - 2 << endl;
        }else if(m == 1){
            cout << n - 2 << endl;
        }else{
            cout << 1LL*(n-2)*(m-2) << endl;
        }
    }
    return 0;
}
```

# 思路

研究[x, y]这个格子变化几次即可

分类讨论

+ 当n = 1且m = 1时
>[1,1]变化一次，朝上， 结果为1

+ 当n,m有一个为1，且另一个不为1时， 以m = 1讨论，n = 1同理
>**边缘2个点：**
`X.......X`
取其中一个点分析：
`XO.......`
会受到隔壁1个点和本身翻转的影响，变化2次，朝上
**中间的点（n - 2）个点：**
`.XXXXXXX.`
取其中一个点分析：
`...OXO...`
隔壁有2个点和本身翻转的影响，变化3次，朝下
所以只有**中间的（n-2）个点**是朝下的

+ 当n,m皆>=2时
>**边角4个点(左上，左下，右上，右下)：**
`X......X`
`........`
`........`
`........`
`X......X`
取其中一个点分析：
`XO......`
`OO......`
`........`
`........`
`........`
受到附近3个点和本身翻转的影响，变化4次，朝上
**除点外，边上的(2n+2m-4)个点**
`.XXXXXX.`
`X......X`
`X......X`
`X......X`
`.XXXXXX.`
取其中一个点分析：
`..OXO...`
`..OOO...`
`........`
`........`
`........`
受到附近5个点和本身翻转的影响，变化6次，朝上
**中间的((n-2)\*(m-2))个点**
`........`
`.XXXXXX.`
`.XXXXXX.`
`.XXXXXX.`
`........`
取其中一个点分析：
`........`
`..OOO...`
`..OXO...`
`..OOO...`
`........`
受到附近8个点和本身翻转的影响，变化9次，朝下
所以只有**中间的（n-2）\*(m-2)个点**是朝下的