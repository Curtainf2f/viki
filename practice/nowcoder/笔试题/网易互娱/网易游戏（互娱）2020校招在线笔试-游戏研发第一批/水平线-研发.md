# 水平线-研发
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 64M，其他语言128M
```
伞屉国是一个以太阳能为主要发电手段的国家，因此他们国家中有着非常多的太阳能基站，链接着的基站会组合成一个发电集群。但是不幸的是伞屉国不时会遭遇滔天的洪水，当洪水淹没基站时，基站只能停止发电，同时被迫断开与相邻基站的链接。你作为伞屉国的洪水观察员，有着这样的任务：在洪水到来时，计算出发电集群被洪水淹没后被拆分成了多少个集群。

由于远古的宇宙战争的原因，伞屉文明是一个二维世界里的文明，所以你可以这样理解发电基站的位置与他们的链接关系：给你一个一维数组a，长度为n，表示了n个基站的位置高度信息。数组的第i个元素a[i]表示第i个基站的海拔高度是a[i],而下标相邻的基站才相邻并且建立链接，即x号基站与x-1号基站、x+1号基站相邻。特别的，1号基站仅与2号相邻，而n号基站仅与n-1号基站相邻。当一场海拔高度为y的洪水到来时，海拔高度小于等于y的基站都会被认为需要停止发电，同时断开与相邻基站的链接。


输入描述:
每个输入数据包含一个测试点。

第一行为一个正整数n，表示发电基站的个数 (0 < n <= 200000)

接下来一行有n个空格隔开的数字，表示n个基站的海拔高度，第i个数字a[i]即为第i个基站的海拔高度，对于任意的i(1<=i<=n),有(0 <= a[i] < 2^31-1)

接下来一行有一个正整数q(0 < q <= 200000)，表示接下来有q场洪水

接下来一行有q个整数，第j个整数y[j]表示第j场洪水的海拔为y[j],对于任意的j(1<=j<=n),有(-2^31 < y[j] < 2^31-1)

输出描述:
输出q行，每行一个整数，第j行的整数ans表示在第j场洪水中，发电基站会被分割成ans个集群。标准答案保证最后一个整数后也有换行。

输入例子1:
```
10
6 12 20 14 15 15 7 19 18 13 
6
15 23 19 1 17 24
```

输出例子1:
```
2
0
1
1
2
0
```

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5+5;

int h[N], in[N];
bool vis[N];
pair<int, int> p[N];
map<int, int> ans;

int main(){
    int n, q;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) scanf("%d", &h[i]), p[i].first = h[i], p[i].second = i;
    sort(p+1, p+1+n, greater<pair<int, int> >());
    int cnt = 0;
    for(int i = 1; i <= n; i ++){
        int cur = 0;
        if(vis[p[i].second-1] && h[p[i].second-1] >= p[i].first){
            cur ++;
        }
        if(vis[p[i].second+1] && h[p[i].second+1] >= p[i].first){
            cur ++;
        }
        cnt += 1 - cur;
        vis[p[i].second] = true;
        ans[p[i].first] = cnt;
    }
    scanf("%d", &q);
    while(q --){
        int x;
        scanf("%d", &x);
        printf("%d\n", ans.upper_bound(x)->second);
    }
    return 0;
}
```

# 思路

预处理 + 二分

1. 从一座发电站都没有，到逐渐出现，也就是让海拔从高到低预处理
为了节省时间，我们只需要直接把海拔定到数据，给出的海拔高度， 这样最多转移n次

2. 刚开始的集群数为0， 当下标为 i 的发电站出现，集群的变化
    1) 左右两侧皆有工作中的发电站，1x1， 那么 集群数 - 1
    2) 左或右有一个发电站在工作， 1x0 or 0x1， 那么集群数不变
    3) 左右两侧都没有工作中的发电站， 0x0， 那么集群数 + 1

3. 将各海拔高度拥有的集群数存入map，进行二分即可出解

复杂度
1. 输入，记录海拔为h[i]的下标，p {h[i], i}，复杂度 $O(n)$
2. 排序，将发电站按海拔高到低排序， 复杂度$O(nlogn)$
3. 根据发电站海拔高度，调整海拔逐渐由高到低，并记录集群，复杂度[集群变化$O(n)$, 记录集群map$O(nlogn)$]
4. 二分记录找解，复杂度$O(qlogn)$

最终复杂度 $O(nlogn)$ 符合预期