# 手机屏幕解锁模式
```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```

现有一个 3x3 规格的 Android 智能手机锁屏程序和两个正整数 m 和 n ，请计算出使用最少m 个键和最多 n个键可以解锁该屏幕的所有有效模式总数。
其中有效模式是指：
1、每个模式必须连接至少m个键和最多n个键；
2、所有的键都必须是不同的；
3、如果在模式中连接两个连续键的行通过任何其他键，则其他键必须在模式中选择，不允许跳过非选择键（如图）；
4、顺序相关，单键有效（这里可能跟部分手机不同）。

输入：m,n
代表允许解锁的最少m个键和最多n个键
输出：
满足m和n个键数的所有有效模式的总数


输入例子1:
```
1,2
```

输出例子1:
```
65
```

例子说明1:
输入m=1，n=2，表示最少1个键，最多2个键，符合要求的键数是1个键和2个键，其中1个键的有效模式有9种，两个键的有效模式有56种，所以最终有效模式总数是9+56=65种，最终输出65。

# 代码
```cpp
class Solution {
public:
    /**
     * 实现方案
     * @param m int整型 最少m个键
     * @param n int整型 最多n个键
     * @return int整型
     */
// bool vis[11];
// int ans[11];
// map<pair<int, int>, int> mp;

// void dfs(int x, int d = 0, int pre = 0){
//     if(mp.find({x, pre}) != mp.end() && !vis[mp[{x, pre}]]) return;
//     vis[x] = true;
//     ans[d+1] ++;
//     for(int i = 1; i <= 9; i ++){
//         if(!vis[i]){
//             dfs(i, d+1, x);
//         }
//     }
//     vis[x] = false;
// }

// int main(){
//     for(int i = 1; i <= 3; i ++) mp[{i, i+6}] = i+3, mp[{i+6, i}] = i+3;
//     for(int i = 1; i <= 7; i += 3) mp[{i, i+2}] = i+1, mp[{i+2, i}] = i+1;
//     mp[{1, 9}] = 5, mp[{9, 1}] = 5;
//     mp[{3, 7}] = 5, mp[{7, 3}] = 5;
//     for(int i = 1; i <= 9; i ++) dfs(i);
//     for(int i = 1; i <= 9; i ++) cout << ans[i] << endl;
//     return 0;
// }

    int ans[10] = {0, 9, 56, 320, 1624, 7152, 26016, 72912, 140704, 140704};
    int solution(int m, int n) {
        if(m < 0) m = 0;
        if(m > 9) m = 9;
        if(n < 0) n = 0;
        if(n > 9) n = 9;
        int ret = 0;
        for(int i = m; i <= n; i ++) ret += ans[i];
        return ret;
    }
};
```

# 思路

搜索遍历全部情况

+ 当需要经过某个点时，比如1划到3经过2(未选中过)，那在搜索时就必定存在另一条分支1-2-3，所以只需要将这种情况剪去即可避免重复(搜索代码为注释部分)

+ 结果可离线，数据量少没必要前缀和，注意n,m范围